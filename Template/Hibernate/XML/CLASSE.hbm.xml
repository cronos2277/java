<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<!-- PARA CADA ENTIDADE, SERA NECESSARIO UM "CLASSE".hbm.xml, CASO O MESMO SEJA FEITO POR NOTACAO XML. -->
<hibernate-mapping>
    <!-- 
        aqui configura classe, o name é o nome da classe ".java" 
    e o table é o nome da tabela no banco de dados. Java é case sensetive.
    -->
    <class name="SUACLASSE" table="SUA_TABELA_NO_BD">   
        
        <!-- A tag do id é diferente mesmo, mas aqui no exemplo tem o campo igual aos outros. -->      
        <id name="ATRIBUTO_CLASSE" column="ATRIBUTO_TABELA">        
        <!-- Estrategia para criacao de ID, o incremente faz com que a geracao de ID seja criado pela aplicacao, nao indicado caso necessite de concorrencia. -->
            <generator class="increment"/>
        </id>
            <!-- Ou se voce quiser que a sequencia seja definida pelo banco de dados -->
        <!--
            <id name="ATRIBUTO_CLASSE" column="ATRIBUTO_TABELA">
                <param name="sequence ou identity">NOME_DA_SEQUENCIA</param>
            </id>
        -->

        <!-- Aqui eh a propriedade de cada coluna da tabela, sendo name o nome do atributo do arquivo .java informado no class="name" -->                    
        <!-- Colunm eh o campo referente ao banco de dados, no caso nesse campo você informa a qual coluna ele referencia no banco de dados. -->
        <property name="ATRIBUTO_CLASSE" column="ATRIBUTO_TABELA" />
        <property name="ATRIBUTO_CLASSE" column="ATRIBUTO_TABELA"/>
        <property name="ATRIBUTO_CLASSE" column="ATRIBUTO_TABELA"/>
        <!-- Caso tenha uma colection na sua entidade, voce pode usar essa estrutura abaixo: -->
        <!-- Esse tipo de estrutura com o set, evita de que voce tenha que ficar criando um outro arquivo hbm.xml. -->
        <set name="NOME_ENTIDADE" table="NOME_TABELA_NO_BD">
            <key column="CHAVE_PRIMARIA_TABELA"/>
            <!-- Um element desse para cada atributo da tabela, aqui abaixo voce usa o padrao do seu banco de dados como tipo. -->
            <element column="NOME_DA_COLUNA_COM_REFERENTE_A_COLLECTION" type="string"/>
        </set>
        <!--
            O component eh uma forma de voce dividir uma tabela do banco de dados
            em duas ou mais entidade, no caso voce poderia incluir a entidade que nao
            tem a chave primaria como uma extensao. Caso todos os campos de uma tabela
            no banco de dados esteja em uma unica entidade, esse component eh desnecessario.

        -->
        <component name="O_ATRIBUTO_DO_TIPO_ENTIDADE_DA_CLASSE_JAVA_REFERENCIADO_NA_ENTIDADE-PRINCIPAL">
            <!-- Repare que a mesma suporta um property assim como o no pai -->
            <property name="ATRIBUTO_DA_ENTIDADE">
            <!-- 
                Caso o nome do atributo nao seja igual ao atributo no banco de dados, 
                voce precisa informar aqui, entre outros atributos. No caso de proprieades
                compostas use o hifen para separar como o "not-null abaixo". As propriedades
                exceto a name nao precisam refletir a realidade do banco de dados. No caso
                o atributo sera tratado como not-null, mesmo que no banco de dados nao seja assim.
            -->
                <column name="ATRIBUTO_NO_BANCO_DE_DADOS" not-null="true"></column>
            </property>
        </component>       
    </class>
    <!-- 
        Caso voce queira incluir a query no arquivo xml, coloqueo dentro da tag query.
        O mesmo deve estar dentro de um CDATA para que nao seja interpolado, na hora 
        de compilar o XML, ou seja isso pode dar erro se nao estiver dentro de CDATA.
        a query deve ter pelo menos um nome, ao qual sera usado para acessar essa query
        salva aqui. Essa query ela requer um parametro, mas eh perfeitamente possivel
        criar uma query aqui que nao exija parametro. Para fazer uso, use o metodo 
        getNameQuery de um objeto org.hibernate.Session. Dentro do metodo 
        "getNamedQuery(queryName)", aonde esta queryName, voce passa em formato de 
        String o nome da query, nesse caso ficaria: 
        seuObjeto.getNamedQuery("NOME_DA_QUERY");         
        Porem voce deve salvar esse resultado dentro de um Objeto org.hibernate.query.Query
        Para isso voce deve seguir o padrao abaixo:
        org.hibernate.query.Query query = objetoSession.seuObjeto.getNamedQuery("NOME_DA_QUERY");
        CASO TENHA PARAMETRO, FACA O SEGUINTE, MAS APENAS SE TIVER PARAMETRO:
        query.setString(name, val) -> name o nome do atributo na query, nesse exemplo abaixo 
        voce colocaria "parametro", entre String e sem os dois pontos, no val voce colocaria
        o valor a substituido no lugar do :parametro (nesse caso em especifico), em formato
        de string. Porem caso o valor nao seja string, o valor a ser informado, voce pode
        por exemplo mudar de setString para setSEUTIPO, assim sendo: query.setInteger("nome","valor"),
        por exemplo, em algumas queries em que se exige valores inteiros, pode se dar problemas
        ao usar o setString, como o between o in, ou ate mesmo para alguma operacao aritimetica,
        se esse erro o ocorrer, troque o setString para o valor apropriado. Lembrando, se houver
        mais de um parametro essa funcao "set" deve ser executada mais de uma vez, se por exemplo,
        houver um valor inteiro e um valor string, entao deve Executar um setInteger e depois um 
        setString, siga sempre a sequencia da esquerda para a direita ao definir parametros para
        manter a ordem e a organizacao.               
        Voce poderia caso nao tenha nenhum parametro na query, ja executar a query e ja passar o 
        resultado direto para um List, exemplo:
        objetoSession.seuObjeto.getNamedQuery("NOME_DA_QUERY").list();
        Mas lembre-se ao chamar o metodo list acima a query sera executada, e nisso, se houver
        parametro(s) os mesmos deveram ser substituidos, antes de ocorrer a execucao da query,
        impossibilitando o uso caso tenha parametros. Caso opte por usar o metodo acima, isso
        te livra de criar um objeto Query.
        Voce pode contar com o metodo do Objeto Query, que implementa a interface Query, 
        eles contem o setMaxResults(InteiroResultadoMaximo), sendo InteiroResultadoMaximo o numero
        maximo de resultados permitidos e setFirstResult(InteiroDaOndeInicia), que define o ponto
        de partida, exemplo se colocar o valor 1 como InteiroDaOndeInicia, o resultado comecara
        da segunda ocorrencia, de toda forma voce pode usar o objeto Query que implementa uma
        interface de mesmo nome para trabalhar com essa query abaixo.
        Voce tambem pode usar a APi criteria no lugar da Query:
        Criteria crit = session.createCriteria(SuaEntidade.class);
        List results = crit.list()
        Para mais informacoes: https://docs.jboss.org/hibernate/orm/3.2/api/org/hibernate/Criteria.html
        Query: https://docs.jboss.org/hibernate/orm/3.2/api/org/hibernate/Query.html
        Session: https://docs.jboss.org/hibernate/orm/3.5/javadocs/org/hibernate/Session.html
    -->
    <query name="NOME_DA_QUERY">
        <![CDATA[ from Entidade where id = :parametro]]>
    </query>
</hibernate-mapping>
<!-- APAGUE OS COMENTARIOS QUANDO USAR O TEMPLATE, PARA EVITAR ERROS DE COMPILACAO. -->